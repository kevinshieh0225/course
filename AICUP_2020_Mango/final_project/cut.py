# -*- coding: utf-8 -*-
"""cut.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EeU0kibC0jiT9bYizSUEL4vMWn5AC1Q9
"""

import os
from glob import glob
import cv2
import matplotlib.pyplot as plt
import re
import numpy as np
import math
from matplotlib.font_manager import FontProperties
plt.rc('font', family='serif', size=10)


font = FontProperties(fname='./ukai.ttc', size=12) # for showing chinese character
def plot_process(images):
    for img in images:
        plt.figure()
        plt.imshow(img)

def dist(pos1, pos2):
    sum_square = 0
    for i, k in zip(pos1, pos2):
        sum_square += (i - k) ** 2
    return math.sqrt(sum_square)

def intersection(rect1, rect2):
    x = max(rect1[0], rect2[0])
    y = max(rect1[1], rect2[1])
    w = min(rect1[0]+rect1[2], rect2[0]+rect2[2]) - x
    h = min(rect1[1]+rect1[3], rect2[1]+rect2[3]) - y
    if w<0 or h<0: return (0,0,0,0)
    return (x, y, w, h)

def check_mango(boxes, cut):
    box_area = 0
    inter_area = 0
    for box in boxes:
        box_area += box[2]*box[3]  # w*h
        inter = intersection(box, cut)
        inter_area += inter[2]*inter[3]
    if box_area>0:
        return inter_area/box_area
    return 0

def load_mango_csv(csv_path,dir_path):
    path = []
    box = []
    label = []
    subdir = csv_path.split('/')[-1].split('.')[0].capitalize()
    with open(csv_path, 'r', encoding='utf8') as f:        
        for line in f:
            clean_line = re.sub(',+\n', '', line).replace('\n', '').replace('\ufeff', '').split(',')
            curr_img_path = f'{dir_path}/{subdir}/{clean_line[0]}'
            curr_info = np.array(clean_line[1:]).reshape(-1, 5)
            curr_box = curr_info[:, :-1].astype('float16').tolist()
            curr_label = curr_info[:, -1].tolist()
            path.append(curr_img_path)
            box.append(curr_box)
            label.append(curr_label)
    return path, box, label

def find_mango(img, isCut=True, box=None):
    '''
    Description:
        > Find the position of the target mango in the image. 
        
    Args:
        img: a input image(BGR)
        isCut: If True, return the cut image; instead return the original image with mark indicating the position.
        box: list of positions of the defective part in the image
        
    Returns:
        img: depends on isCut return the assigned image(BGR, resized to (224,224)).
        ratio: None, if box is None. Instead, return the correctness of this process

    '''
    height, width, _ = img.shape
    rgb_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    hsv_img = cv2.cvtColor(rgb_img, cv2.COLOR_RGB2HSV)
    
    # filter red and orange
    lower_red = np.array([150,43,46])
    upper_red = np.array([180,255,255])
    lower_orange = np.array([0,43,46])
    upper_orange = np.array([35,255,255])
    red_mask = cv2.inRange(hsv_img, lower_red, upper_red)
    orange_mask = cv2.inRange(hsv_img, lower_orange, upper_orange)
    mask = red_mask + orange_mask
    res = cv2.bitwise_and(hsv_img, hsv_img, mask=mask)
    res_bgr = cv2.cvtColor(res, cv2.COLOR_HSV2BGR)
    gray = cv2.cvtColor(res_bgr, cv2.COLOR_BGR2GRAY)
    _, binary = cv2.threshold(gray,50,255,cv2.THRESH_BINARY)  
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    # Select the contour by the size of area and the distance from the origin of the image.
    c = max(contours, key=cv2.contourArea)
    cnt =sorted(contours, key=cv2.contourArea, reverse=True)  # a descending list of contours by area.
    score = 0
    for i in range(min(5, len(cnt))):
        area = cv2.contourArea(cnt[i])
        if area > 0:
            hull = cv2.convexHull(cnt[i]) # shape should be a convexhull
            M = cv2.moments(hull)
            cx = int(M['m10']/M['m00'])
            cy = int(M['m01']/M['m00'])
            d = int(dist((cx, cy), (width/2, height/2)))
            curr_score = area / d if d>0 else area
            if curr_score>score:
                score = curr_score
                c = hull    
    x,y,w,h = cv2.boundingRect(c)
    
    # Preserve some margins
    tol_x = 0.1 * w # the percentage of margin
    tol_y = 0.1 * h
    x2 = min(width, x+w+tol_x)
    y2 = min(height, y+h+tol_y)
    x = int(max(0, x-tol_x))
    y = int(max(0, y-tol_y))
    w = int(x2 - x)
    h = int(y2 - y)
    
    rt_img = img.copy()
    ratio = None
    thres = 0.7
    if not (box is None):
        ratio = check_mango(box, (x,y,w,h))
        if isCut and ratio>thres:
            rt_img = rt_img[y:y+h, x:x+w]
        elif not isCut:
            rt_img = cv2.rectangle(rt_img,(x,y),(x+w,y+h),(0,0,255),2)
            for curr_box in box:
                start_point = (int(curr_box[0]), int(curr_box[1]))
                end_point = (int(curr_box[0] + curr_box[2]), int(curr_box[1] + curr_box[3]))
                rt_img = cv2.rectangle(rt_img, start_point, end_point, (0, 255, 0), 3)
    else:
        if isCut:
            rt_img = rt_img[y:y+h, x:x+w]
        else:
            rt_img = cv2.rectangle(rt_img,(x,y),(x+w,y+h),(0,0,255),2)

    # when debugging, uncomment this part
#     cv2.drawContours(binary, contours, -1, (255,0,0), 5)
#     images = [hsv_img, red_mask, orange_mask, gray, binary, rt_img]
#     plot_process(images)
    
    rt_img = cv2.resize(rt_img, (224, 224))
    return rt_img, ratio


def cut_mango(path, dest=None, isCut=True, box=None):
    '''
    Description:
        >  a image preprocessor to locate the mango
        
    Args:
        img: all paths of image
        dest: If is None, return the image array(BGR). Otherwise, save images into 'dest' Directory.
        isCut: If True, images will be the cut image; instead images will be the original image with mark indicating the position.
        box: list of positions of the defective part in the image
        
    Returns:
        img: depends on dest either return a list of the assigned images(BGR) ,or a list of the paths where images store.

    '''
    haveCut = False
    rt_img = []
    # check if there is already have cut mango
    if not(dest is None):
      curr_path = path[0]
      indx = [s.start() for s in re.finditer('/', curr_path)][-2]
      file_path = dest + curr_path[indx:]
      if os.path.isfile(file_path):
        haveCut = True

    if not haveCut:
      sum_ratio = 0
      miss = 0
      problem = []
      for i in range(len(path)):
          if i%100 == 0:
              print(i)
          choose_idx = i
          curr_path = path[choose_idx]
          # use TRY because some images are missing in the image folder
          try:
            curr_img = cv2.imread(curr_path)
            curr_box = None
            if not (box is None):
                curr_box = box[choose_idx]
            cut_img, ratio = find_mango(curr_img.copy(), box=curr_box, isCut=isCut)
            
            if not (ratio is None):
                sum_ratio += ratio
                thres = 0.7
                if ratio < thres:
                    miss += 1
                    problem.append(choose_idx)
            if dest is None:
                rt_img.append(cut_img)
            else:
                indx = [s.start() for s in re.finditer('/', curr_path)][-2]
                file_path = dest + curr_path[indx:]
                cv2.imwrite(file_path, cut_img)
                rt_img.append(file_path)
          except:
            rt_img.append(None)
      
      if not (box is None):
          print('Cut mango:')
          print('Amount of Miss:', miss)
          print('Average correctness:', sum_ratio/len(path))
          print('Indices of incorrect img', problem)
    else:
      print('Already have cut mango!')
      for i in range(len(path)):
        curr_path = path[i]
        indx = [s.start() for s in re.finditer('/', curr_path)][-2]
        file_path = dest + curr_path[indx:]
        rt_img.append(file_path)
    
    return rt_img


if __name__ == '__main__':
  # dir_path = "./C2_TrainDev_Toy"
  # dest = "./C2_TrainDev_Toy_After_Cut"
  dir_path = "./../AICUP_2020_Mango/C2_TrainDev"
  dest = "./../AICUP_2020_Mango/C2_TrainDev_After_Cut"

  subdir = ['Dev', 'Train']
  for sub in subdir:
    new_dir = os.path.join(dest, sub)
    if not os.path.isdir(new_dir):
      try:
          os.makedirs(new_dir)
      except OSError as e:
          print(e)
      else:
          print(f"Successfully created the directory {new_dir}")
  path, box, label = load_mango_csv(csv_path=f'{dir_path}/train.csv')
  print('Start Cutting')
  cut_img = cut_mango(path, dest=dest, isCut=True, box=box)
  print('Finish Cutting')